"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// import * as Module from 'module';
const path = require("path");
const util = require("util");
const vm = require("vm");
const lodash_1 = require("lodash");
const logger_1 = require("../utils/logger");
const devnull_1 = require("../utils/devnull");
const properties_1 = require("../plugin/properties");
const Module = require('module');
const BLACKLISTED_GLOBALS = [
    'reallyExit',
    'abort',
    'chdir',
    'umask',
    'setuid',
    'setgid',
    'setgroups',
    '_kill',
    'EventEmitter',
    '_maxListeners',
    '_fatalException',
    'exit',
    'kill',
];
// @see node/lib/internal/module.js
function makeRequireFunction() {
    const require = (p) => this.require(p);
    require.resolve = (request) => Module._resolveFilename(request, this);
    require.main = process.mainModule;
    // Enable support to add extra extension types
    require.extensions = Module._extensions;
    require.cache = Module._cache;
    return require;
}
// @see node/lib/module.js
function compileInSandbox(sandbox) {
    // eslint-disable-next-line
    return function (content, filename) {
        const require = makeRequireFunction.call(this);
        const dirname = path.dirname(filename);
        // remove shebang
        // eslint-disable-next-line
        const newContent = content.replace(/^\#\!.*/, '');
        const wrapper = Module.wrap(newContent);
        const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });
        const args = [this.exports, require, this, filename, dirname];
        return compiledWrapper.apply(this.exports, args);
    };
}
function createDebugFunction(filename) {
    return (...args) => {
        const debugId = path.basename(filename);
        const sout = util.format.apply(null, [`[${debugId}]`].concat(args));
        logger_1.logger.info(sout);
    };
}
function createSandbox(filename) {
    const module = new Module(filename);
    module.paths = Module._nodeModulePaths(filename);
    const sandbox = vm.createContext({
        module,
        console: {},
    });
    lodash_1.defaults(sandbox, global);
    // Redirect console calls into logger
    Object.keys(console).forEach((k) => {
        if (k === 'log') {
            sandbox.console.log = createDebugFunction(filename);
        }
        else if (k in logger_1.logger) {
            sandbox.console[k] = logger_1.logger[k];
        }
    });
    sandbox.require = function sandboxRequire(p) {
        const oldCompile = Module.prototype._compile;
        Module.prototype._compile = compileInSandbox(sandbox);
        const moduleExports = sandbox.module.require(p);
        Module.prototype._compile = oldCompile;
        return moduleExports;
    };
    // patch `require` in sandbox to run loaded module in sandbox context
    // if you need any of these, it might be worth discussing spawning separate processes
    sandbox.process = lodash_1.omit(process, BLACKLISTED_GLOBALS);
    const devNull = new devnull_1.DevNull();
    sandbox.process.stdin = devNull;
    sandbox.process.stdout = devNull;
    sandbox.process.stderr = devNull;
    return sandbox;
}
// inspiration drawn from Module
function createPlugin(filename, nvim, options = {}) {
    const debug = createDebugFunction(filename);
    try {
        const sandbox = createSandbox(filename);
        const specs = [];
        const handlers = {};
        // Clear module from cache
        if (options && !options.cache) {
            delete Module._cache[require.resolve(filename)];
        }
        // attempt to import plugin
        // Require plugin to export a class
        const defaultImport = sandbox.require(filename);
        const Wrapper = (defaultImport && defaultImport.default) || defaultImport;
        // Only process decorated objects
        if (Wrapper && Wrapper[properties_1.NVIM_PLUGIN]) {
            const Child = Object.getPrototypeOf(Wrapper);
            // Search for decorated methods
            Object.getOwnPropertyNames(Child.prototype).forEach(methodName => {
                const method = Wrapper.prototype[methodName];
                if (method && method[properties_1.NVIM_SPEC]) {
                    // Add spec
                    specs.push(method[properties_1.NVIM_SPEC]);
                    const handlerId = [filename, method[properties_1.NVIM_METHOD_NAME]].join(':');
                    handlers[handlerId] = methodName;
                }
            });
            return {
                shouldCache: !Wrapper[properties_1.NVIM_DEV_MODE],
                sandbox,
                specs,
                handlers,
                import: defaultImport,
                module: !options || !options.noCreateInstance ? new Wrapper(nvim) : null,
            };
        }
    }
    catch (err) {
        debug(`Error loading child ChildPlugin ${filename}`);
        debug(err);
    }
    // There may have been an error, but maybe not
    return null;
}
function loadPlugin(filename, nvim, options = {}) {
    try {
        return createPlugin(filename, nvim, options);
    }
    catch (err) {
        // logger.error(`Could not load plugin "${filename}":`, err, err.stack);
        return null;
    }
}
exports.loadPlugin = loadPlugin;
