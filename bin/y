#!/usr/bin/env racket
#lang racket/base
(require racket/match
         racket/list
         racket/format
         racket/port
         racket/system
         racket/date
         web-server/servlet
         web-server/http)

(define VLC-PATH
  (find-executable-path "vlc"))
(define FFPROBE-PATH
  (find-executable-path "ffprobe"))
(define HOME (find-system-path 'home-dir))
;; xxx generalize from URL?
;; xxx recursive showing
;; xxx polite vs impolite
(define ROOT (build-path HOME "Downloads" "YouTube"))

(define (ffprobe p)
  (define-values (sp o i e)
    (subprocess #f #f #f FFPROBE-PATH "-show_format" p))
  (subprocess-wait sp)
  (string->number
   (second
    (for/or ([x (in-list (port->lines o))])
      (regexp-match #rx"^duration=(.*?)$" x)))))
(define LEN-CACHE (make-hash))
(define (yf-len a-yf)
  (define p (yf-path a-yf))
  (match-define
   (cons when len)
   (hash-ref! LEN-CACHE p
              (位 ()
                (cons (yf-msecs a-yf)
                      (ffprobe p)))))
  (cond
    [(= when (yf-msecs a-yf))
     len]
    [else
     (hash-remove! LEN-CACHE p)
     (yf-len a-yf)]))

(struct yf (status name path msecs))
(define (yf-equal? x y)
  (equal? (yf-name x) (yf-name y)))
(define (yf-played? a-yf)
  (member (yf-status a-yf) '(R S)))
(define (yf-unplayed? a-yf)
  (eq? 'U (yf-status a-yf)))
(define (yf-mdates a-yf)
  (parameterize ([date-display-format 'iso-8601])
    (date->string (seconds->date (yf-msecs a-yf)))))
(define (yf-lens a-yf)
  (define MINUTES 60)
  (define   HOURS (* 60 MINUTES))
  (define L (inexact->exact (floor (yf-len a-yf))))
  (define-values (H HR) (quotient/remainder L HOURS))
  (define-values (M S) (quotient/remainder HR MINUTES))
  (~a (~a #:width 2 #:pad-string "0" H) ":"
      (~a #:width 2 #:pad-string "0" M) ":"
      (~a #:width 2 #:pad-string "0" S)))

(define (y-files-all)
  (define ps (directory-list ROOT))
  (define fs
    (parameterize ([current-directory ROOT])
      (filter file-exists? ps)))
  (define yfs
    (for/list ([pp (in-list fs)])
      (define p (build-path ROOT pp))
      (define f (path->string pp))
      (define msecs (file-or-directory-modify-seconds p))
      (yf (cond
            [(regexp-match #rx".part$" f)
             'P]
            [else
             (string->symbol (string (string-ref f 0)))])
          (substring f 1)
          p
          msecs)))
  (sort yfs <= #:key yf-msecs))
(define (y-files-unplayed)
  (filter yf-unplayed? (y-files-all)))

(define (make-y-http)
  (define current-vlc-lock (make-semaphore 1))
  (define current-vlc-yf #f)
  (define continuous? #f)
  (define (is-current-vlc-yf? f)
    (and current-vlc-yf
         (yf-equal? current-vlc-yf f)))

  (define (play! f)
    (when (semaphore-try-wait? current-vlc-lock)
      (set! current-vlc-yf f)
      (printf "Starting VLC on ~a\n" (yf-name f))
      (define-values
        (sp o i e)
        (subprocess
         (current-output-port) (current-input-port) (current-error-port)
         VLC-PATH
         (yf-path f)
         "vlc://quit"))
      (thread
       (位 ()
         (printf "Waiting on VLC\n")
         (subprocess-wait sp)
         (printf "VLC Done\n")
         (set! current-vlc-yf #f)
         (semaphore-post current-vlc-lock)
         (with-handlers ([exn:fail? void])
           (mark! f 'R))
         (when continuous?
           (play-next! f))))))
  (define (play-next! f)
    (printf "Continuous play...\n")
    (define fs (y-files-all))
    (define f-and (member f fs yf-equal?))
    (when f-and
      (define f-and-un (filter yf-unplayed? (rest f-and)))
      (unless (empty? f-and-un)
        (play! (first f-and-un)))))

  (define (clean!)
    (for ([f (in-list (y-files-all))]
          #:when (eq? 'R (yf-status f)))
      (delete-file (yf-path f))))
  (define (mark! f s)
    (unless (is-current-vlc-yf? f)
      (printf "Marking ~a as ~a\n" (yf-name f) s)
      (define old (yf-path f))
      (define n (yf-name f))
      (define new
        (build-path ROOT
                    (string-append (symbol->string s) n)))
      (rename-file-or-directory old new)))
  (define (toggle-continuous?!)
    (set! continuous? (not continuous?)))
  (define (restart!)
    (local-require mzlib/os)
    (system (format "kill -9 ~a" (getpid))))

  (define (y-http req)
    (send/suspend/dispatch
     (位 (embed/url)
       (define (do f . args)
         (embed/url
          (位 (req)
            (apply f args)
            (redirect-to "/"))))
       (response/xexpr
        #:preamble #"<!DOCTYPE html>"
        `(html
          ;; xxx add nice css, buttons, etc
          (head (title "y"))
          (body
           (div
            (span
             ,(date->string (current-date) #t) ":"
             " "
             ,(if current-vlc-yf
                "playing "
                "")
             (a
              ([href ,(do toggle-continuous?!)]
               [style
                   ,(if continuous?
                      "font-weight: bold"
                      "text-decoration: line-through")])
              "continuous")
             " "
             (a ([href ,(do clean!)]) "clean")
             " "
             (a ([href ,(do restart!)]) "restart")))
           (table
            ,@(for/list ([f (in-list (y-files-all))])
                `(tr (td ,(yf-mdates f))
                     (td
                      ,(if (eq? 'P (yf-status f))
                         `,(yf-name f)
                         `(a ([href ,(do play! f)])
                             ,(yf-name f))))
                     (td ,(yf-lens f))
                     (td
                      ,(if (is-current-vlc-yf? f)
                         "!"
                         "")
                      ,(match (yf-status f)
                         ['U "U"]
                         ['P "P"]
                         ['R "R"]
                         ['S "S"])
                      ,@(let ()
                          (define menu
                            (match (yf-status f)
                              ['P empty]
                              ['U (list (cons "R" (do mark! f 'R)))]
                              ['R (list (cons "U" (do mark! f 'U))
                                        (cons "S" (do mark! f 'S)))]
                              ['S (list (cons "R" (do mark! f 'R)))]))
                          (for/list ([l*u (in-list menu)])
                            `(a ([href ,(cdr l*u)]) ,(car l*u))))))))))))))

  y-http)

(module+ main-miro-rename
  (require db
           racket/path)
  (define conn
    (sqlite3-connect #:database (build-path HOME ".miro" "sqlitedb")
                     #:mode 'read-only))
  (define rs
    (rows-result-rows
     (query conn "select filename,entry_title,torrent_title from item")))
  (for ([r (in-list rs)])
    (match-define (vector fn et tt) r)
    (unless (sql-null? fn)
      (define f (file-name-from-path fn))
      (define Uf (build-path ROOT (string-append "U" (path->string f))))
      (when (file-exists? Uf)
        (define nt
          (cond
            [(not (sql-null? tt))
             tt]
            [(not (sql-null? et))
             et]
            [else
             (error 'y "no title: ~a\n" fn)]))
        (rename-file-or-directory
         Uf
         (build-path ROOT (format "U~a" nt)))))))

(module+ main
  (require web-server/servlet-env)

  (match (current-command-line-arguments)
    [(vector)
     (serve/servlet (make-y-http)
                    #:launch-browser? #f
                    #:servlet-regexp #rx""
                    #:port 7331)]
    [(vector x)
     (parameterize ([current-directory ROOT])
       (system* (find-executable-path "youtube-dl")
                "--continue"
                "--embed-subs"
                "--output"
                "U%(uploader)s - %(title)s.%(ext)s"
                x))]))
