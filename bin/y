#!/usr/bin/env racket
#lang racket/base
(require racket/match
         racket/list
         racket/format
         racket/port
         racket/system
         racket/date
         web-server/servlet
         web-server/http)

(define VLC-PATH
  (find-executable-path "vlc"))
(define LYNX-PATH
  (find-executable-path "links"))
(define FFPROBE-PATH
  (find-executable-path "ffprobe"))
(define HOME (find-system-path 'home-dir))
;; xxx generalize from URL?
(define ROOT (build-path HOME "Downloads" "YouTube"))

(define (ffprobe p)
  (define-values (sp o i e)
    (subprocess #f #f #f FFPROBE-PATH "-show_format" p))
  (subprocess-wait sp)
  (string->number
   (second
    (for/or ([x (in-list (port->lines o))])
      (regexp-match #rx"^duration=(.*?)$" x)))))
(define LEN-CACHE (make-hash))
(define (yf-len a-yf)
  (define p (yf-path a-yf))
  (match-define
   (cons when len)
   (hash-ref! LEN-CACHE p
              (λ ()
                (cons (yf-msecs a-yf)
                      (ffprobe p)))))
  (cond
    [(= when (yf-msecs a-yf))
     len]
    [else
     (hash-remove! LEN-CACHE p)
     (yf-len a-yf)]))

(struct yf (status name path msecs))
(define (yf-played? a-yf)
  (not (eq? 'U (yf-status a-yf))))
(define (yf-mdates a-yf)
  (parameterize ([date-display-format 'iso-8601])
    (date->string (seconds->date (yf-msecs a-yf)))))
(define (yf-lens a-yf)
  (define MINUTES 60)
  (define   HOURS (* 60 MINUTES))
  (define L (inexact->exact (floor (yf-len a-yf))))
  (define-values (H HR) (quotient/remainder L HOURS))
  (define-values (M S) (quotient/remainder HR MINUTES))
  (~a (~a #:width 2 #:pad-string "0" H) ":"
      (~a #:width 2 #:pad-string "0" M) ":"
      (~a #:width 2 #:pad-string "0" S)))

(define (y-files-all)
  (define ps (directory-list ROOT))
  (define fs
    (parameterize ([current-directory ROOT])
      (filter file-exists? ps)))
  (define yfs
    (for/list ([pp (in-list fs)])
      (define p (build-path ROOT pp))
      (define f (path->string pp))
      (define msecs (file-or-directory-modify-seconds p))
      (yf (string->symbol (string (string-ref f 0)))
          (substring f 1)
          p
          msecs)))
  (sort yfs <= #:key yf-msecs))

(define (y-files-unplayed)
  (filter-not yf-played? (y-files-all)))

(define (y-mark-played! f)
  (rename-file-or-directory
   f
   (string-append "R" (substring f 1))))

(define (y-play)
  (define fs (y-files-unplayed))
  (cond
    [(empty? fs)
     #f]
    [else
     (define f (first fs))
     (define r (system* VLC-PATH f))
     (printf "~a -> ~a\n" f r)
     ;; (y-mark-played! f)
     #t]))

(define (y-play-all)
  (and (y-play)
       (y-play-all)))

(define (play! f)
  (printf "Playing ~a\n" f))
(define (play-from! f)
  (printf "Playing from ~a\n" f))

(define (y-http req)
  (send/suspend/dispatch
   (λ (embed/url)
     (define (do f . args)
       (embed/url
        (λ (req)
          (apply f args)
          (y-http req))))
     (response/xexpr
      #:preamble #"<!DOCTYPE html>"
      `(html
        (head (title "y"))
        (body
         (div (span "delete played"))
         (table
          ([id "playlist"])
          ,@(for/list ([f (in-list (y-files-all))])
              `(tr (td ,(yf-mdates f))
                   (td ,(match (yf-status f)
                          ['U "new"]
                          ['R "old"]
                          ['S "saved"]))
                   (td (a ([href ,(do play! f)])
                          ,(yf-name f))
                       (a ([href ,(do play-from! f)])
                          "(from)"))
                   (td ,(yf-lens f))
                   (td
                    ,(match (yf-status f)
                       ['U "played"]
                       ['R `(span "unplayed"
                                  "save")]
                       ['S "unsave"])))))))))))

(module+ main-miro-rename
  (require db
           racket/path)
  (define conn
    (sqlite3-connect #:database (build-path HOME ".miro" "sqlitedb")
                     #:mode 'read-only))
  (define rs
    (rows-result-rows
     (query conn "select filename,entry_title,torrent_title from item")))
  (for ([r (in-list rs)])
    (match-define (vector fn et tt) r)
    (unless (sql-null? fn)
      (define f (file-name-from-path fn))
      (define Uf (build-path ROOT (string-append "U" (path->string f))))
      (when (file-exists? Uf)
        (define nt
          (cond
            [(not (sql-null? tt))
             tt]
            [(not (sql-null? et))
             et]
            [else
             (error 'y "no title: ~a\n" fn)]))
        (rename-file-or-directory
         Uf
         (build-path ROOT (format "U~a" nt)))))))

(module+ main
  (require web-server/servlet-env)

  (serve/servlet y-http
                 #:launch-browser? #f
                 #:servlet-regexp #rx""
                 #:port 7331))
